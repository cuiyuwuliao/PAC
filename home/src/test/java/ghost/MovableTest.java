/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package ghost;

import java.util.*;
import java.io.*;
import processing.core.*;

import org.junit.jupiter.api.*;
import static org.junit.jupiter.api.Assertions.assertAll;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertNotNull;
import static org.junit.jupiter.api.Assertions.assertThrows;
import static org.junit.jupiter.api.Assertions.assertTimeout;
import static org.junit.jupiter.api.Assertions.assertTimeoutPreemptively;
import static org.junit.jupiter.api.Assertions.assertTrue;
import static org.junit.jupiter.api.Assertions.assertArrayEquals;


class MovableTest{
    Resources r = new Resources("simpleMap.json");
    Engine game = r.game;


    @BeforeEach
    public void resetMovable(TestInfo info){
    	if (info.getDisplayName().equals("reset()") || info.getDisplayName().equals("movableSetting()")){
    		return; 
  		}
  		game.p1.reset(game);
    }

    @Test 
    public void movableSetting(){
        //movable constronct correctly
    	assertEquals(game.p1.v, 2);
    	assertEquals(game.p1.x, 16);
    	assertEquals(game.p1.y, 16);
    	assertEquals(game.p1.going, null);
    	assertEquals(game.p1.command, null);
    	int[] pLoc = {1,1};
    	Grid expectedGrid = game.map.searchByLoc(pLoc);
    	assertEquals(game.p1.currentGrid, expectedGrid);
    	assertEquals(game.p1.nextGrid, null);
    	assertEquals(game.p1.startingXY[0], 16);
    	int[] expectedXY = {16, 16};
    	assertArrayEquals(game.p1.startingXY, expectedXY);
    	assertEquals(game.p1.type, Basic.MoveType.player);  
    }

    @Test 
    public void reset(){
        //reset method rest movable location
    	game.p1.x = 1000;
    	game.p1.y = 1000;
    	game.p1.command = Dir.up;
    	game.p1.command = Dir.down;
    	game.p1.command = Dir.down;
    	game.p1.currentGrid = game.map.searchByLoc(new int[] {1,2});
    	game.p1.reset(game);
    	assertEquals(game.p1.x, game.p1.startingXY[0]);
    	assertEquals(game.p1.y, game.p1.startingXY[1]);
        assertEquals(game.p1.command, null);
        assertEquals(game.p1.going, null);
        Grid expectedGrid = game.map.searchByLoc(new int[] {1,1});
        assertEquals(game.p1.currentGrid, expectedGrid);
    }

    @Test 
    public void setSpeed(){
        //set speed, speed can't be lower than 0
    	game.p1.setSpeed(100);
    	assertEquals(game.p1.v, 100);
    	game.p1.setSpeed(-100);
    	assertEquals(game.p1.v, 0);
    }

    @Test 
    public void setGoing(){
        //set direction going, going can be null(stop)
        PImage test = null;
        Normal m = new Normal(test,1,1);
        m.setGoing(Dir.left);
        assertEquals(m.going, Dir.left);
        m.setGoing(null);
        assertEquals(m.going, null);
        
    }



    @Test 
    public void setCommand(){
        //set direction command, going can be null
    	game.p1.setCommand(Dir.down);
    	assertEquals(game.p1.command, Dir.down);
    	game.p1.setCommand(null);
    	assertEquals(game.p1.command, null);
    }

    @Test 
    public void move(){
        // move according to it's direction going and speed
    	game.p1.setSpeed(1);
    	game.p1.setGoing(Dir.up);
    	game.p1.move();
    	assertEquals(game.p1.y, 15);
    	game.p1.setGoing(Dir.down);
    	game.p1.move();
    	assertEquals(game.p1.y, 16);
    	game.p1.setGoing(Dir.left);
    	game.p1.move();
    	assertEquals(game.p1.x, 15);
    	game.p1.setGoing(Dir.right);
    	game.p1.move();
    	assertEquals(game.p1.x, 16);
    }

    @Test 
    public void readGrid(){
        //readGrid update currentGrid and nextGrid
    	game.p1.setGoing(Dir.right);
    	game.p1.readGrid(game);
    	int[] pLoc = {1,1};
    	Grid expectedGrid = game.map.searchByLoc(pLoc);
    	assertEquals(game.p1.currentGrid, expectedGrid);
    	expectedGrid = game.map.gridNearBy(expectedGrid, Dir.right);
    	assertEquals(game.p1.nextGrid, expectedGrid);
    }

    @Test 
    public void ops(){
        //return opposite direction, null will return null
    	Dir[] test = {Dir.up, Dir.left, Dir.right, Dir.down};
    	int i = 3;
    	for(Dir d : test){
    		assertEquals(Movable.ops(test[i]), d);
    		i -= 1;
    	}
    	assertEquals(Movable.ops(null), null);

    }

    


    @Test 
    public void tick_noCommand(){
        //going to wall will set going to null, without command, object stop
    	game.p1.setGoing(Dir.left);
    	game.p1.tick(game);
    	assertEquals(game.p1.going, null);
    	assertEquals(game.p1.command, null);
    	assertEquals(game.p1.moveLog.size(), 0);
        //going to non-wall direction won't set going to null
    	game.p1.setGoing(Dir.right);
    	game.p1.tick(game);
    	assertEquals(game.p1.going, Dir.right);
    	assertEquals(game.p1.command, null);
    	assertEquals(game.p1.moveLog.size(), 0);
    }

    @Test 
    public void tick_validCommand(){
        //valid command execution set going to command and set command to null
        //valid command execution update movelog
    	game.p1.setGoing(Dir.left);
    	game.p1.setCommand(Dir.right);
    	game.p1.tick(game);
    	assertEquals(game.p1.going, Dir.right);
    	assertEquals(game.p1.command, null);
    	Dir lastMove = game.p1.moveLog.get((game.p1.moveLog.size()-1));
    	assertEquals(lastMove, Dir.right);
    }

    @Test 
    public void tick_invalidCommand(){
        //command toward wall will not be executed
    	game.p1.setGoing(Dir.left);
    	game.p1.setCommand(Dir.up);
    	game.p1.tick(game);
    	assertEquals(game.p1.going, null);
    	assertEquals(game.p1.command, Dir.up);
    	assertEquals(game.p1.moveLog.size(), 0);
    }





   
    
}
